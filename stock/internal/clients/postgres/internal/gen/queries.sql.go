// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const arrival = `-- name: Arrival :exec
with inserted_item as (
insert into items (name, size, sku, available_all)
values ($1, $2, $3, $4)
on conflict (sku) do update
set available_all = items.available_all + excluded.available_all
returning sku
)
insert into item_stock (sku, stock_id, available)
select sku, $5, $4
from inserted_item
on conflict (sku, stock_id) do update
set available = item_stock.available + excluded.available
`

type ArrivalParams struct {
	Name      pgtype.Text
	Size      pgtype.Text
	Sku       int32
	Available pgtype.Int4
	StockID   int32
}

func (q *Queries) Arrival(ctx context.Context, arg *ArrivalParams) error {
	_, err := q.db.Exec(ctx, arrival,
		arg.Name,
		arg.Size,
		arg.Sku,
		arg.Available,
		arg.StockID,
	)
	return err
}

const getItemsByStock = `-- name: GetItemsByStock :many
select i.sku, ist.available, ist.reserved
from item_stock ist
    join items i on ist.sku = i.sku
where ist.stock_id = $1
`

type GetItemsByStockRow struct {
	Sku       int32
	Available pgtype.Int4
	Reserved  pgtype.Int4
}

func (q *Queries) GetItemsByStock(ctx context.Context, stockID int32) ([]*GetItemsByStockRow, error) {
	rows, err := q.db.Query(ctx, getItemsByStock, stockID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetItemsByStockRow
	for rows.Next() {
		var i GetItemsByStockRow
		if err := rows.Scan(&i.Sku, &i.Available, &i.Reserved); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatusStockAvailability = `-- name: GetStatusStockAvailability :one
select s.status
from stocks st
    join statuses s on st.status_id = s.id
where st.id = $1
`

func (q *Queries) GetStatusStockAvailability(ctx context.Context, id int32) (string, error) {
	row := q.db.QueryRow(ctx, getStatusStockAvailability, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const reserve = `-- name: Reserve :exec
update item_stock
set available = available - $2,
    reserved = reserved + $2
where sku = $1 and stock_id = $3
`

func (q *Queries) Reserve(ctx context.Context, sku int32, available pgtype.Int4, stockID int32) error {
	_, err := q.db.Exec(ctx, reserve, sku, available, stockID)
	return err
}

const reserveCancel = `-- name: ReserveCancel :exec
update item_stock
set available = available + $2,
    reserved = reserved - $2
where sku = $1 and stock_id = $3
`

func (q *Queries) ReserveCancel(ctx context.Context, sku int32, available pgtype.Int4, stockID int32) error {
	_, err := q.db.Exec(ctx, reserveCancel, sku, available, stockID)
	return err
}

const updateItem = `-- name: UpdateItem :exec
update items
set available_all = available_all + $2,
    reserved_all = reserved_all + $3
where sku = $1
`

func (q *Queries) UpdateItem(ctx context.Context, sku int32, availableAll pgtype.Int4, reservedAll pgtype.Int4) error {
	_, err := q.db.Exec(ctx, updateItem, sku, availableAll, reservedAll)
	return err
}
